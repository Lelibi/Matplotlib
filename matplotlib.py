# -*- coding: utf-8 -*-
"""Matplotlib.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Kk1qUwIXpRZaZpevjSUarG5-GDwESd8F

# O **Matplotlib** é uma biblioteca popular em Python usada para criar visualizações de dados, como gráficos de linhas, barras, histogramas, dispersões, entre outros tipos de gráficos. É uma ferramenta poderosa, especialmente útil em ciência de dados, estatística, engenharia e machine learning, por ser altamente personalizável e suportar a criação de gráficos 2D e até animações.

---

**Interface Simples (pyplot):**

**import matplotlib.pyplot as plt:**


*   O módulo pyplot é a interface principal da Matplotlib para a criação de gráficos. Ele oferece funções semelhantes às usadas no MATLAB, que permitem desenhar gráficos, definir rótulos, títulos, escalas, etc.
*   Ao importar como plt, você pode usar o plt para chamar essas funções de forma mais compacta.

Exemplo
"""

plt.plot([1, 2, 3], [4, 5, 6])  # Cria um gráfico simples (x, y)
plt.show()  # Exibe o gráfico

"""Exemplo"""

import matplotlib.pyplot as plt

x = [1, 2, 3, 4]
y = [10, 20, 25, 30]

plt.plot(x, y)
plt.xlabel('X')
plt.ylabel('Y')
plt.title('Coloque um titulo aqui')
plt.show()

"""O **Matplotlib** permite personalizar quase todos os aspectos dos gráficos: cores, estilos de linhas, marcadores, rótulos de eixos, títulos, tamanhos de fontes, legendas, entre outros."""

plt.plot(x, y, color='red', linestyle='--', marker='o', label='Linha 1')
plt.legend( )  # Adiciona a legenda "Linha 1"
plt.xlabel('Eixo X')
plt.ylabel('Eixo Y')
plt.title('Gráfico Personalizado')
plt.grid(True)  # Adiciona grade ao gráfico

"""Exemplo"""

plt.scatter([1, 2, 3, 4], [10, 20, 25, 30])
plt.show()

"""**import matplotlib.patches as mpatches:**



*   O módulo patches fornece classes para criar formas geométricas como retângulos, círculos, polígonos e outras figuras. Essas formas são chamadas de "patches" e podem ser adicionadas a gráficos.

Exemplo:
"""

circle = mpatches.Circle((0.5, 0.5), 0.2, color='pink')  # Cria um círculo
plt.gca().add_patch(circle)  # Adiciona o círculo ao gráfico atual
plt.show()  # Exibe o gráfico

"""**import matplotlib.path as mpath:**



*  O módulo path oferece ferramentas para criar caminhos customizados, que podem ser usados para desenhar formas complexas, como curvas e trajetórias, usando uma sequência de comandos para definir os vértices e segmentos.


"""

Path = mpath.Path
fig, ax = plt.subplots()

path_data = [
    (Path.MOVETO, (1.0, 1.0)),  # Move para o ponto inicial
    (Path.LINETO, (2.0, 2.0)),  # Desenha uma linha para o próximo ponto
    (Path.LINETO, (2.0, 1.0)),  # Outra linha
    (Path.CLOSEPOLY, (1.0, 1.0))  # Fecha o polígono
]
codes, verts = zip(*path_data)
path = mpath.Path(verts, codes)
patch = mpatches.PathPatch(path, facecolor='black')
ax.add_patch(patch)

#plot control points and connecting lines
x, y = zip(*path.vertices)
line, = ax.plot(x, y, 'go-')

ax.grid()
ax.axis('equal')
plt.show()

plt.show()

import matplotlib.pyplot as plt

import matplotlib.patches as mpatches
import matplotlib.path as mpath

fig, ax = plt.subplots()

Path = mpath.Path
path_data = [
    (Path.MOVETO, (1.58, -2.57)), # primeiro ponto no plano
    (Path.LINETO, (0.35, -1.1)), # o desenho segue em linha reta até o próximo ponto
    (Path.CURVE4, (-1.75, 2.0)), # o desenho se curva até o proximo ponto
    (Path.CURVE4, (0.375, 2.0)), # o desenho se curva até o proximo ponto
    (Path.LINETO, (0.85, 1.15)), # o desenho segue em linha reta até o próximo ponto
    (Path.CURVE4, (2.2, 3.2)), # o desenho se curva até o proximo ponto
    (Path.CURVE4, (3, 0.05)), # o desenho se curva até o proximo ponto
    (Path.CURVE4, (2.0, -0.5)), # o desenho se curva até o proximo ponto
    (Path.CLOSEPOLY, (1.58, -2.57)), #fechar o vertices
    ]
codes, verts = zip(*path_data)
path = mpath.Path(verts, codes)
patch = mpatches.PathPatch(path, facecolor="red", alpha=1)
ax.add_patch(patch)

# plot control points and connecting lines
x, y = zip(*path.vertices)
line, = ax.plot(x, y, 'go-')

ax.grid()
ax.axis('equal')
plt.show()

!apt-get install imagemagick #caso você esteja usando o Google colab


import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

# Configurações iniciais do gráfico
fig, ax = plt.subplots()
x = np.linspace(0, 2 * np.pi, 128)
line, = ax.plot(x, np.sin(x))

# Função de animação que atualiza o gráfico a cada frame
def update(frame):
    line.set_ydata(np.sin(x + frame / 10.0))  # Atualiza os valores de y
    return line,

# Criação da animação (100 frames, com intervalo de 50 ms entre eles)
ani = animation.FuncAnimation(fig, update, frames=100, interval=50)

# Salvar a animação como GIF
ani.save('sine_wave.gif', writer='imagemagick')

# Exibir o GIF no Google Colab
from IPython.display import Image
Image(filename='sine_wave.gif')

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

# Função para desenhar o coração
def heart_function(t):
    x = 16 * np.sin(t) ** 3
    y = 13 * np.cos(t) - 5 * np.cos(2 * t) - 2 * np.cos(3 * t) - np.cos(4 * t)
    return x, y

# Criando os valores de t para desenhar o coração
t = np.linspace(0, 2 * np.pi, 1000)
x, y = heart_function(t)

# Configurações iniciais do gráfico
fig, ax = plt.subplots()
ax.set_aspect('equal')
ax.set_xlim(-20, 20)
ax.set_ylim(-20, 20)
line, = ax.plot([], [], color='red')

# Função de atualização para a animação
def update(frame):
    scale = 1 + 0.05 * np.sin(frame / 10.0)  # Simulando o "batimento" do coração
    line.set_data(scale * x, scale * y)
    return line,

# Criando a animação
ani = animation.FuncAnimation(fig, update, frames=100, interval=50)

# Salvando a animação como GIF
ani.save('heart_animation.gif', writer='imagemagick')

# Exibir o GIF no Google Colab
from IPython.display import Image
Image(filename='heart_animation.gif')